### 과제 풀이 (생성자 정리)
TV, Refrigerator 객체 생성 후, 값 저장 및 불러오기

* **static : class 단위의 변수가 된다.**
  class가 선언될 때 단 한번 선언되며, 한 클래스의 변수가 객체 모두에게 영향을 준다.

* 생성자 : 아주 특별한 메소드
  객체 생성시에 호출되어 초기화
  이름 = 클래스이름
  return 타입이 없음. (void라는 말이 아니라 return 개념이 없음. void 쓰면 안됨)
  한 class 안에 여러개의 생성자 정의가 가능하다 (overloading)  
  * overloading : 다중 정의, 똑같이 생겼지만 이름은 같지만 매개변수가 달라야 한다.
  생성자는 상속이 되지 않는다.
  class내에 생상자가 단 1개도 없을 시, 자동으로 컴파일러가 기본 생성자 추가
  
#####  생성자 편하게 생성하는 법 ==> 우클릭 + source + generate constructor using field

* **모든 class에 default 생성자가 생기진 않는다( new FileOutputStream)**
---
#### Access Modifier
* private : only 자신
* (default) : same package
* protected : same package but, 자식 class는 다른 package에서도 호출이 가능.
* public : all
---
#### method 재정의(다시 정의)
  전제조건 : 상속
  상속받은 method를 다시 정의한다.
  * method 이름이 같아야한다.
  * 매개변수 리스트가 같아야한다.
  * 리턴타입이 같아야한다.
---
#### this
  method, 생성자안에서 현재 생성(실행)중인 객체 자기자신을 가리키는 reference.
  static에는 사용하지 못한다.
  this는 compile 때가 아니라 runtime 때 값을 가져옴
  => 내장 변수 느낌
  * 지역변수와 멤버변수 이름이 같을때 구분하기 위해 사용 ex) this.변수
  * 생성자가 다중정의되어 있는 상황에서 자신의 또 다른 생성자를 호출할 때 사용 ex) this (    )
  * 자기자신을 다른 객체에 전달하기 위해 사용 (이건 자주 나오지는 않음)
  
  '''Java
  public TV(String no, String name, int price){
    //TV(no, name)이라고 호출 불가하고 호출하려면 new를 붙여야 하는데
    //이러면 객체가 하나 더 생성되는 불상사가 생김
    //이러한 문제를 해결하기위해 this를 사용
    this(no, name);
    this.price = price;
  }
  
  public TV(String no, String name){
    this.no = no;
    this.name = name;
  }
  '''
    
